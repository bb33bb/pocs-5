# Linux Kernel NetFilter XTABLES out-of-bounds read vulnerability


## Summary
The out-of-bounds read vulnerability lies in u32_match_it function, which is a component of netfilter that would possible to call via input or output hooks of network stack.

This vulnerability has lived 10+ years more over in the linux kernel (since from linux kernel 2.6).

CONFIG_NFT_COMPAT and CONFIG_NETFILTER_XTABLES should be `m` or `y`. I confirmed this config on Ubuntu that it is `m` and loaded on the boot time.


## Detail
```c
#define XT_U32_MAXSIZE 10

struct xt_u32_test {
	struct xt_u32_location_element location[XT_U32_MAXSIZE+1];
	struct xt_u32_value_element value[XT_U32_MAXSIZE+1];
	__u8 nnums;
	__u8 nvalues;
};

struct xt_u32 {
	struct xt_u32_test tests[XT_U32_MAXSIZE+1];
	__u8 ntests;
	__u8 invert;
};


static bool u32_match_it(const struct xt_u32 *data,
			 const struct sk_buff *skb)
{
...
	for (testind = 0; testind < data->ntests; ++testind) {
		ct  = &data->tests[testind]; <<< [1]
		at  = 0;
		pos = ct->location[0].number;

		if (skb->len < 4 || pos > skb->len - 4)
			return false;

		if (skb_copy_bits(skb, pos, &n, sizeof(n)) < 0)
			BUG();
		val   = ntohl(n);
		nnums = ct->nnums;

		/* Inner loop runs over "&", "<<", ">>" and "@" operands */
		for (i = 1; i < nnums; ++i) {
            ...
        }

		/* Run over the "," and ":" operands */
		nvals = ct->nvalues;
		for (i = 0; i < nvals; ++i)
			if (ct->value[i].min <= val && val <= ct->value[i].max)
				break;

		if (i >= ct->nvalues)
			return false;
	}

	return true;
}

static bool u32_mt(const struct sk_buff *skb, struct xt_action_param *par)
{
	const struct xt_u32 *data = par->matchinfo;
	bool ret;

	ret = u32_match_it(data, skb);
	return ret ^ data->invert;
}

static struct xt_match xt_u32_mt_reg __read_mostly = {
	.name       = "u32",
	.revision   = 0,
	.family     = NFPROTO_UNSPEC,
	.match      = u32_mt,
	.matchsize  = sizeof(struct xt_u32),
	.me         = THIS_MODULE,
}
```


`par->matchinfo` of u32_mt function is allocated via kmalloc with size sizeof(struxt xt_u32) and `par->matchinfo` heap data is user-supplied data.

On the u32_match_it function, without validating elements of xt_u32 structure, it tries to get `data->ntests` and use this as a loop-count number.

The element of xt_u32 structure `data->tests` is allocated 10 array of xt_u32_test structure, so if an attacker set `data->ntests` more than 11, referencing `data->tests[testind]` is would be read from next heap chunk of `data` variable - thus out-of-bounds read occurs.

* Please note that you might not see kasan log if you run PoC because whether continue or break for-loop syntax for the out-of-bounds is depended on the next heap chunk of struct xt_u32 `data` value.

## KASAN log
```
[   23.779765] ==================================================================
[   23.780991] BUG: KASAN: slab-out-of-bounds in u32_mt+0x654/0x6a0
[   23.780991] Read of size 1 at addr ffff88810206486c by task ping/305
[   23.780991]
[   23.780991] CPU: 0 PID: 305 Comm: ping Not tainted 5.18.12 #14
[   23.780991] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
[   23.780991] Call Trace:
[   23.780991]  <IRQ>
[   23.780991]  dump_stack_lvl+0x49/0x5f
[   23.780991]  print_report.cold+0x5e/0x5cf
[   23.780991]  ? u32_mt+0x654/0x6a0
[   23.780991]  kasan_report+0xaa/0x120
[   23.780991]  ? u32_mt+0x654/0x6a0
[   23.780991]  __asan_report_load1_noabort+0x14/0x20
[   23.780991]  u32_mt+0x654/0x6a0
[   23.780991]  ? time_mt+0x500/0x500
[   23.780991]  ? get_stack_info_noinstr+0x17/0x100
[   23.780991]  nft_match_large_eval+0x1d1/0x390
[   23.780991]  ? nft_target_eval_bridge+0x350/0x350
[   23.780991]  ? is_bpf_text_address+0x24/0x30
[   23.780991]  ? kernel_text_address+0xc7/0xd0
[   23.780991]  nft_do_chain+0x309/0x18d0
[   23.780991]  ? create_prof_cpu_mask+0x30/0x30
[   23.780991]  ? arch_stack_walk+0x9e/0xf0
[   23.780991]  ? __nft_trace_verdict.isra.0+0x20/0x20
[   23.780991]  ? __kasan_check_write+0x14/0x20
[   23.780991]  ? reweight_entity+0x3d4/0x580
[   23.780991]  ? debug_smp_processor_id+0x17/0x20
[   23.780991]  ? nohz_balance_exit_idle+0x23/0x280
[   23.780991]  ? __kasan_check_read+0x11/0x20
[   23.780991]  ? trigger_load_balance+0x194/0xa70
[   23.780991]  ? clear_posix_cputimers_work+0x90/0x90
[   23.780991]  ? scheduler_tick+0x296/0x660
[   23.780991]  ? __kasan_check_write+0x14/0x20
[   23.780991]  ? read_hpet+0x150/0x200
[   23.780991]  ? hpet_rtc_timer_init.part.0+0x130/0x130
[   23.780991]  nft_do_chain_ipv4+0x18c/0x220
[   23.780991]  ? nft_do_chain_netdev+0x7b0/0x7b0
[   23.780991]  ? memset+0x3c/0x50
[   23.780991]  nf_hook_slow+0xbb/0x1a0
[   23.780991]  ip_rcv+0x12c/0x380
[   23.780991]  ? ip_rcv_finish+0x1e0/0x1e0
[   23.780991]  ? check_preempt_curr+0x161/0x250
[   23.780991]  ? ip_sublist_rcv+0x700/0x700
[   23.780991]  ? ttwu_do_wakeup+0x24/0x560
[   23.780991]  ? ip_rcv_finish+0x1e0/0x1e0
[   23.780991]  __netif_receive_skb_one_core+0x167/0x1c0
[   23.780991]  ? __netif_receive_skb_list_core+0xa00/0xa00
[   23.780991]  ? __kasan_check_write+0x14/0x20
[   23.780991]  ? _raw_spin_lock_irq+0x8e/0xe0
[   23.780991]  __netif_receive_skb+0x21/0x190
[   23.780991]  ? _raw_spin_lock_irq+0x8e/0xe0
[   23.780991]  process_backlog+0x16e/0x4c0
[   23.780991]  ? process_timeout+0x31/0x40
[   23.780991]  __napi_poll+0xae/0x450
[   23.780991]  net_rx_action+0x706/0x9d0
[   23.780991]  ? napi_threaded_poll+0x3d0/0x3d0
[   23.780991]  ? clockevents_program_event+0x1eb/0x2b0
[   23.780991]  ? debug_smp_processor_id+0x17/0x20
[   23.780991]  __do_softirq+0x1ab/0x5ad
[   23.780991]  do_softirq.part.0+0xcf/0x110
[   23.780991]  </IRQ>
[   23.780991]  <TASK>
[   23.780991]  __local_bh_enable_ip+0x7f/0x90
[   23.780991]  ip_finish_output2+0x644/0x1d60
[   23.780991]  ? crng_make_state+0x250/0x250
[   23.780991]  ? ip_setup_cork+0x990/0x990
[   23.780991]  ? __ip_append_data+0x1258/0x4070
[   23.780991]  __ip_finish_output+0x234/0x3f0
[   23.780991]  ip_finish_output+0x2b/0x1f0
[   23.780991]  ip_output+0x1c0/0x3a0
[   23.780991]  ? ip_finish_output+0x1f0/0x1f0
[   23.780991]  ? __ip_make_skb+0xda8/0x2090
[   23.780991]  ? __ip_finish_output+0x3f0/0x3f0
[   23.780991]  ip_push_pending_frames+0x156/0x1a0
[   23.780991]  raw_sendmsg+0xf2d/0x2b50
[   23.780991]  ? walk_system_ram_range+0xfe/0x170
[   23.780991]  ? raw_setsockopt+0x210/0x210
[   23.780991]  ? post_alloc_hook+0x165/0x1b0
[   23.780991]  ? set_pte+0x79/0xb0
[   23.780991]  ? aa_sk_perm+0x12a/0x690
[   23.780991]  ? __zone_watermark_ok+0x310/0x310
[   23.780991]  ? rwsem_down_read_slowpath+0x880/0x880
[   23.780991]  ? aa_af_perm+0x240/0x240
[   23.780991]  ? __kasan_check_read+0x11/0x20
[   23.780991]  inet_sendmsg+0xc9/0xf0
[   23.780991]  ? raw_setsockopt+0x210/0x210
[   23.780991]  ? inet_sendmsg+0xc9/0xf0
[   23.780991]  ? inet_send_prepare+0x2b0/0x2b0
[   23.780991]  sock_sendmsg+0xe5/0x120
[   23.780991]  __sys_sendto+0x1db/0x2e0
[   23.780991]  ? __ia32_sys_getpeername+0xb0/0xb0
[   23.780991]  ? folio_add_lru+0x8a/0xd0
[   23.780991]  ? perf_callchain_user+0x160/0xa60
[   23.780991]  ? __kasan_check_write+0x14/0x20
[   23.780991]  ? hpet_rtc_timer_init.part.0+0x130/0x130
[   23.780991]  ? ktime_get_real_ts64+0x85/0x1a0
[   23.780991]  ? ktime_get_real_ts64+0x85/0x1a0
[   23.780991]  __x64_sys_sendto+0xe0/0x1a0
[   23.780991]  ? debug_smp_processor_id+0x17/0x20
[   23.780991]  ? fpregs_assert_state_consistent+0x4e/0xb0
[   23.780991]  do_syscall_64+0x5c/0x80
[   23.780991]  ? syscall_exit_to_user_mode+0x26/0x40
[   23.780991]  ? do_syscall_64+0x69/0x80
[   23.780991]  ? exit_to_user_mode_prepare+0x49/0x190
[   23.780991]  ? irqentry_exit_to_user_mode+0x9/0x20
[   23.780991]  ? irqentry_exit+0x33/0x40
[   23.780991]  ? exc_page_fault+0x72/0xe0
[   23.780991]  ? asm_exc_page_fault+0x8/0x30
[   23.780991]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[   23.780991] RIP: 0033:0x7f2a7a6e9e63
[   23.780991] Code: 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb d0 0f 1f 84 00 00 00 00 00 83 3d a9 48 2b 00 00 75 13 49 89 ca b8 2c 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 34 c3 48 83 ec 08 e8 8b b6 00 00 48 89 04 24
[   23.780991] RSP: 002b:00007fffdd8aff18 EFLAGS: 00000246 ORIG_RAX: 000000000000002c
[   23.780991] RAX: ffffffffffffffda RBX: 000055cc4a8129c0 RCX: 00007f2a7a6e9e63
[   23.780991] RDX: 0000000000000040 RSI: 000055cc4a8129c0 RDI: 0000000000000004
[   23.780991] RBP: 0000000000000040 R08: 000055cc4a80f800 R09: 0000000000000010
[   23.780991] R10: 0000000000000000 R11: 0000000000000246 R12: 00007fffdd8b1640
[   23.780991] R13: 000055cc4a8129c0 R14: 000055cc4a80e3a0 R15: 00007fffdd8b1640
[   23.780991]  </TASK>
[   23.780991]
[   23.780991] Allocated by task 300:
[   23.780991]  kasan_save_stack+0x26/0x50
[   23.780991]  __kasan_kmalloc+0x88/0xa0
[   23.780991]  __kmalloc+0x1bc/0x380
[   23.780991]  nft_match_large_init+0xa1/0x170
[   23.780991]  nf_tables_newrule+0xdce/0x2a80
[   23.780991]  nfnetlink_rcv_batch+0xeb4/0x1fd0
[   23.780991]  nfnetlink_rcv+0x2f0/0x3b0
[   23.780991]  netlink_unicast+0x5ec/0x890
[   23.780991]  netlink_sendmsg+0x81f/0xd00
[   23.780991]  sock_sendmsg+0xec/0x120
[   23.780991]  __sys_sendto+0x1db/0x2e0
[   23.780991]  __x64_sys_sendto+0xe0/0x1a0
[   23.780991]  do_syscall_64+0x5c/0x80
[   23.780991]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[   23.780991]
[   23.780991] The buggy address belongs to the object at ffff888102064000
[   23.780991]  which belongs to the cache kmalloc-2k of size 2048
[   23.780991] The buggy address is located 108 bytes to the right of
[   23.780991]  2048-byte region [ffff888102064000, ffff888102064800)
[   23.780991]
[   23.780991] The buggy address belongs to the physical page:
[   23.780991] page:0000000090465679 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x102060
[   23.780991] head:0000000090465679 order:3 compound_mapcount:0 compound_pincount:0
[   23.780991] flags: 0x17ffffc0010200(slab|head|node=0|zone=2|lastcpupid=0x1fffff)
[   23.780991] raw: 0017ffffc0010200 ffffea000402d400 dead000000000002 ffff888100042000
[   23.780991] raw: 0000000000000000 0000000080080008 00000001ffffffff 0000000000000000
[   23.780991] page dumped because: kasan: bad access detected
[   23.780991]
[   23.780991] Memory state around the buggy address:
[   23.780991]  ffff888102064700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   23.780991]  ffff888102064780: 00 00 00 00 00 00 00 00 fc fc fc fc fc fc fc fc
[   23.780991] >ffff888102064800: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[   23.780991]                                                           ^
[   23.780991]  ffff888102064880: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[   23.780991]  ffff888102064900: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[   23.780991] ==================================================================
[   23.815478] Disabling lock debugging due to kernel taint
```
